#!/usr/bin/env bash

# cached_ctest - Incremental test runner for CMake/CTest
# Only runs tests whose executables have been rebuilt since last run

set -euo pipefail

# ============================================
# Configuration and Constants
# ============================================
SCRIPT_VERSION="1.0.0"
METADATA_DIR=".cached_ctest"
METADATA_FILE="${METADATA_DIR}/tests_metadata.json"
ANCHOR_FILE="${METADATA_DIR}/anchor_timestamp"

# ============================================
# Global Variables
# ============================================
INCLUDE_REGEX=""
EXCLUDE_REGEX=""
VERBOSE=0
DRY_RUN=0
CTEST_ARGS=()

# ============================================
# Utility Functions
# ============================================

# Print error message and exit
error() {
    echo "Error: $*" >&2
    exit 1
}

# Print verbose message
verbose() {
    if [[ ${VERBOSE} -eq 1 ]]; then
        echo "$*"
    fi
}

# ============================================
# Dependency Checking
# ============================================

check_dependencies() {
    # Check for jq
    if ! command -v jq &> /dev/null; then
        error "jq is required but not installed. Please install jq: https://stedolan.github.io/jq/"
    fi

    # Check for ctest
    if ! command -v ctest &> /dev/null; then
        error "ctest is required but not found. Please install CMake."
    fi
}

# ============================================
# Help and Usage
# ============================================

show_help() {
    cat <<EOF
Usage: cached_ctest [options]

Incremental test runner for CMake/CTest projects.
Only runs tests whose executables have been rebuilt since last run.

Options:
  -R <regex>       Run tests matching regex (include filter)
  -E <regex>       Exclude tests matching regex (exclude filter)
  -V, --verbose    Verbose output
  --dry-run        Show which tests would run without running them
  -h, --help       Show this help message
  --version        Show version information

All other options are passed through to ctest.

Examples:
  cached_ctest                    # Run all modified tests
  cached_ctest -R "math_.*"       # Run modified math tests
  cached_ctest -E "integration"   # Run all except integration tests
  cached_ctest --verbose          # Run with detailed output
  cached_ctest --dry-run          # Preview which tests would run

How it works:
  1. Compares test executable timestamps with anchor file timestamp
  2. Only runs tests whose executables are newer than the anchor
  3. Updates anchor after successful test run
  4. The anchor is automatically updated by the build system

Project: https://github.com/yourusername/cached_ctest
Version: ${SCRIPT_VERSION}
EOF
}

show_version() {
    echo "cached_ctest version ${SCRIPT_VERSION}"
}

# ============================================
# Argument Parsing
# ============================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -R)
                if [[ $# -lt 2 ]]; then
                    error "-R requires an argument"
                fi
                INCLUDE_REGEX="$2"
                shift 2
                ;;
            -E)
                if [[ $# -lt 2 ]]; then
                    error "-E requires an argument"
                fi
                EXCLUDE_REGEX="$2"
                shift 2
                ;;
            -V|--verbose)
                VERBOSE=1
                CTEST_ARGS+=("$1")
                shift
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            *)
                # Pass unknown arguments to ctest
                CTEST_ARGS+=("$1")
                shift
                ;;
        esac
    done
}

# ============================================
# Metadata Validation
# ============================================

validate_metadata() {
    # Check for metadata file
    if [[ ! -f "${METADATA_FILE}" ]]; then
        error "Metadata file not found: ${METADATA_FILE}
Did you:
  1. Include CachedCTest.cmake in your CMakeLists.txt?
  2. Call cached_ctest_init() and cached_ctest_finalize()?
  3. Run 'cmake' and build your project?"
    fi

    # Check for anchor file
    if [[ ! -f "${ANCHOR_FILE}" ]]; then
        error "Anchor file not found: ${ANCHOR_FILE}
Please rebuild the project to generate the anchor timestamp."
    fi

    # Validate JSON format
    if ! jq empty "${METADATA_FILE}" 2>/dev/null; then
        error "Invalid JSON in metadata file: ${METADATA_FILE}"
    fi
}

# ============================================
# Test Filtering
# ============================================

# Check if test name passes the filters
# Returns 0 (success) if test should be included, 1 otherwise
filter_tests() {
    local test_name="$1"

    # Apply include filter (-R)
    if [[ -n "${INCLUDE_REGEX}" ]]; then
        if ! echo "${test_name}" | grep -qE "${INCLUDE_REGEX}"; then
            return 1  # Doesn't match include pattern, skip
        fi
    fi

    # Apply exclude filter (-E)
    if [[ -n "${EXCLUDE_REGEX}" ]]; then
        if echo "${test_name}" | grep -qE "${EXCLUDE_REGEX}"; then
            return 1  # Matches exclude pattern, skip
        fi
    fi

    return 0  # Passes all filters
}

# ============================================
# Timestamp Comparison
# ============================================

# Get file modification time in seconds since epoch
# Cross-platform support for Linux and macOS
get_mtime() {
    local file="$1"

    # Try Linux format first, then macOS format
    local mtime
    mtime=$(stat -c %Y "${file}" 2>/dev/null || stat -f %m "${file}" 2>/dev/null || echo "")

    if [[ -z "${mtime}" ]]; then
        return 1
    fi

    echo "${mtime}"
}

# Check if test executable has been modified since anchor
# Returns 0 (success) if test is modified and should run
is_test_modified() {
    local executable="$1"

    # Check if executable exists
    if [[ ! -f "${executable}" ]]; then
        verbose "  Warning: Executable not found: ${executable}"
        return 1  # Doesn't exist, skip
    fi

    # Get timestamps
    local exe_mtime
    local anchor_mtime

    exe_mtime=$(get_mtime "${executable}")
    anchor_mtime=$(get_mtime "${ANCHOR_FILE}")

    if [[ -z "${exe_mtime}" ]] || [[ -z "${anchor_mtime}" ]]; then
        verbose "  Warning: Cannot read timestamps for ${executable}"
        return 1
    fi

    # Compare timestamps
    if [[ ${exe_mtime} -gt ${anchor_mtime} ]]; then
        return 0  # Modified
    else
        return 1  # Not modified
    fi
}

# ============================================
# Regex Escaping
# ============================================

# Escape special regex characters for ctest filter
# This ensures test names with special characters work correctly
escape_regex() {
    local str="$1"
    # Escape: . [ ] * ^ $ ( ) + ? { } |
    echo "$str" | sed 's/[.[\*^$()+?{|]/\\&/g'
}

# ============================================
# Main Logic
# ============================================

main() {
    parse_arguments "$@"
    check_dependencies
    validate_metadata

    # Read total test count
    local test_count
    test_count=$(jq '.tests | length' "${METADATA_FILE}")

    local -a tests_to_run=()
    local -a tests_skipped=()

    echo "Cached CTest v${SCRIPT_VERSION}"
    echo "Checking ${test_count} registered tests..."
    echo ""

    # Iterate through all tests
    for (( i=0; i<test_count; i++ )); do
        local test_name
        local test_exe

        test_name=$(jq -r ".tests[$i].name" "${METADATA_FILE}")
        test_exe=$(jq -r ".tests[$i].executable" "${METADATA_FILE}")

        # Apply filters
        if ! filter_tests "${test_name}"; then
            verbose "Filtered: ${test_name}"
            continue
        fi

        # Check if modified
        if is_test_modified "${test_exe}"; then
            tests_to_run+=("${test_name}")
            verbose "Modified: ${test_name}"
        else
            tests_skipped+=("${test_name}")
            verbose "Cached:   ${test_name}"
        fi
    done

    # Print summary
    echo "Summary:"
    echo "  Tests to run: ${#tests_to_run[@]}"
    echo "  Tests cached: ${#tests_skipped[@]}"
    echo ""

    # Check if any tests need to run
    if [[ ${#tests_to_run[@]} -eq 0 ]]; then
        echo "No tests need to run (all cached)."
        exit 0
    fi

    # Dry run mode
    if [[ ${DRY_RUN} -eq 1 ]]; then
        echo "Dry run mode - would run these tests:"
        for test in "${tests_to_run[@]}"; do
            echo "  - ${test}"
        done
        exit 0
    fi

    # Build ctest filter regex
    # Escape test names and join with '|'
    local -a escaped_tests=()
    for test in "${tests_to_run[@]}"; do
        escaped_tests+=("$(escape_regex "${test}")")
    done

    # Create regex: ^(test1|test2|test3)$
    local ctest_filter
    ctest_filter="^($(IFS='|'; echo "${escaped_tests[*]}"))$"

    # Run ctest with filter
    echo "Running tests..."
    echo ""

    local exit_code=0
    ctest -R "${ctest_filter}" ${CTEST_ARGS[@]+"${CTEST_ARGS[@]}"} || exit_code=$?

    # Update anchor if tests passed
    if [[ ${exit_code} -eq 0 ]]; then
        echo ""
        echo "All tests passed! Anchor timestamp updated."
        touch "${ANCHOR_FILE}"
    else
        echo ""
        echo "Some tests failed. Anchor timestamp not updated."
    fi

    exit ${exit_code}
}

# Run main function
main "$@"
